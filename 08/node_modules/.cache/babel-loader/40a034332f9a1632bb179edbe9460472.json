{"ast":null,"code":"import storage from './storage';\nimport { useCallback, useEffect, useMemo, useRef, useState } from 'react';\nexport default function useLocalStorageStateBase(key, defaultValue) {\n  // we don't support updating the `defaultValue` the same way `useState()` doesn't support it\n  const [defaultValueState] = useState(() => {\n    const isCallable = value => typeof value === 'function';\n\n    return isCallable(defaultValue) ? defaultValue() : defaultValue;\n  });\n  const getDefaultState = useCallback(() => {\n    return {\n      value: storage.get(key, defaultValueState),\n      isPersistent: (() => {\n        /**\n         * We want to return `true` on the server. If you render a message based on `isPersistent` and the\n         * server returns `false` then the message will flicker until hydration is done:\n         * `{!isPersistent && <span>You changes aren't being persisted.</span>}`\n         */\n        if (typeof window === 'undefined') {\n          return true;\n        }\n\n        try {\n          localStorage.setItem('__ulss', '#');\n          localStorage.removeItem('__ulss');\n          return true;\n        } catch (_a) {\n          return false;\n        }\n      })()\n    };\n  }, [defaultValueState, key]);\n  const [state, setState] = useState(getDefaultState);\n  const updateValue = useMemo(() => {\n    const fn = newValue => {\n      const isCallable = value => typeof value === 'function';\n\n      if (isCallable(newValue)) {\n        setState(state => ({\n          value: newValue(state.value),\n          isPersistent: storage.set(key, newValue(state.value))\n        }));\n      } else {\n        setState({\n          value: newValue,\n          isPersistent: storage.set(key, newValue)\n        });\n      }\n    };\n\n    fn.reset = () => {\n      storage.remove(key);\n      setState(state => ({\n        value: defaultValueState,\n        isPersistent: state.isPersistent\n      }));\n    };\n\n    return fn;\n  }, [key, defaultValueState]);\n  /**\n   * Syncs changes across tabs and iframe's.\n   */\n\n  useEffect(() => {\n    const onStorage = e => {\n      if (e.storageArea === localStorage && e.key === key) {\n        setState({\n          value: storage.get(key, defaultValueState),\n          isPersistent: true\n        });\n      }\n    };\n\n    window.addEventListener('storage', onStorage);\n    return () => window.removeEventListener('storage', onStorage);\n  }, [key, defaultValueState]);\n  /**\n   * Update the state when the `key` property changes.\n   */\n\n  const isFirstRender = useRef(true);\n  useEffect(() => {\n    if (isFirstRender.current) {\n      isFirstRender.current = false;\n      return;\n    }\n\n    setState(getDefaultState());\n  }, [getDefaultState]);\n  return [state.value, updateValue, state.isPersistent];\n}","map":{"version":3,"sources":["/Users/wotim/Documents/05/05/node_modules/use-local-storage-state/es/src/useLocalStorageStateBase.js"],"names":["storage","useCallback","useEffect","useMemo","useRef","useState","useLocalStorageStateBase","key","defaultValue","defaultValueState","isCallable","value","getDefaultState","get","isPersistent","window","localStorage","setItem","removeItem","_a","state","setState","updateValue","fn","newValue","set","reset","remove","onStorage","e","storageArea","addEventListener","removeEventListener","isFirstRender","current"],"mappings":"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","sourcesContent":["import storage from './storage';\nimport { useCallback, useEffect, useMemo, useRef, useState } from 'react';\nexport default function useLocalStorageStateBase(key, defaultValue) {\n    // we don't support updating the `defaultValue` the same way `useState()` doesn't support it\n    const [defaultValueState] = useState(() => {\n        const isCallable = (value) => typeof value === 'function';\n        return isCallable(defaultValue) ? defaultValue() : defaultValue;\n    });\n    const getDefaultState = useCallback(() => {\n        return {\n            value: storage.get(key, defaultValueState),\n            isPersistent: (() => {\n                /**\n                 * We want to return `true` on the server. If you render a message based on `isPersistent` and the\n                 * server returns `false` then the message will flicker until hydration is done:\n                 * `{!isPersistent && <span>You changes aren't being persisted.</span>}`\n                 */\n                if (typeof window === 'undefined') {\n                    return true;\n                }\n                try {\n                    localStorage.setItem('__ulss', '#');\n                    localStorage.removeItem('__ulss');\n                    return true;\n                }\n                catch (_a) {\n                    return false;\n                }\n            })(),\n        };\n    }, [defaultValueState, key]);\n    const [state, setState] = useState(getDefaultState);\n    const updateValue = useMemo(() => {\n        const fn = (newValue) => {\n            const isCallable = (value) => typeof value === 'function';\n            if (isCallable(newValue)) {\n                setState((state) => ({\n                    value: newValue(state.value),\n                    isPersistent: storage.set(key, newValue(state.value)),\n                }));\n            }\n            else {\n                setState({\n                    value: newValue,\n                    isPersistent: storage.set(key, newValue),\n                });\n            }\n        };\n        fn.reset = () => {\n            storage.remove(key);\n            setState((state) => ({\n                value: defaultValueState,\n                isPersistent: state.isPersistent,\n            }));\n        };\n        return fn;\n    }, [key, defaultValueState]);\n    /**\n     * Syncs changes across tabs and iframe's.\n     */\n    useEffect(() => {\n        const onStorage = (e) => {\n            if (e.storageArea === localStorage && e.key === key) {\n                setState({\n                    value: storage.get(key, defaultValueState),\n                    isPersistent: true,\n                });\n            }\n        };\n        window.addEventListener('storage', onStorage);\n        return () => window.removeEventListener('storage', onStorage);\n    }, [key, defaultValueState]);\n    /**\n     * Update the state when the `key` property changes.\n     */\n    const isFirstRender = useRef(true);\n    useEffect(() => {\n        if (isFirstRender.current) {\n            isFirstRender.current = false;\n            return;\n        }\n        setState(getDefaultState());\n    }, [getDefaultState]);\n    return [state.value, updateValue, state.isPersistent];\n}\n"]},"metadata":{},"sourceType":"module"}